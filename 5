#include <iostream>
using namespace std;
void output(float **&arr, int &count, int &currentMoney)
{ //Вывод
    for (int i = 0; i < count; i++)
        if (arr[i][2] == 1000000) //Если предмет полностью вместился
            cout << "1.0 ";
        else if (arr[i][1] == 1000000) //А вот это когда предмет вместился не полностью (стоит заметить, что здесь мы воспольовались визитной карточкой, данной в процедуре fillKnapsack, здесь испорчена именно ячейка ДЕНЕГ[1], а не ячейка соотношения(ценности предмета)[2], т.к. в ячейке соотношения содержится ответ
            cout << arr[i][2] << " ";
        else cout << endl << currentMoney; //Выводим сколько дненег потратили на все это
}

bool fillKnapsack(int bestItem, float **&arr, int &count, int &maxV, int &currentMoney, int &currentV)
{ //Заполнение рюкзака
    if (currentV + arr[bestItem][0] < maxV) //Если ТекущийОбъем рюкзака + Объем самой ценной найденной вещи оказались меньше допустимого Обхема, то можно запихнуть предмет полностью
    {
        currentV += arr[bestItem][0]; //Добавляем объем предмета к объему рюкзака
        arr[bestItem][2] = 1000000; //Портим соотношение предмета, чтобы его больше не брать, т.к. его больше нет
        currentMoney += arr[bestItem][1]; //Ну и добавляем к потраченным деньгам стоимость целого предмета, который пихнули в рюкзак
        return true; //Продолжаем цикл
    }
    else
        if (currentV + arr[bestItem][0] == maxV) //Если ТекущийОбъем рюкзака + Объем самой ценной найденной вещи оказались равными допустимому Обхему, то можно запихнуть предмет полностью, а затем выходить из цикла и завершать прогу
        {
            currentV += arr[bestItem][0]; //Добавляем объем предмета к объему рюкзака
            arr[bestItem][2] = 1000000; //Портим соотношение предмета, чтобы его больше не брать, т.к. его больше нет
            currentMoney += arr[bestItem][1]; //Ну и добавляем к потраченным деньгам стоимость целого предмета, который пихнули в рюкзак
            return false; //Возвращаем False, выходим из цикла
        }
        else
        { //А вот если ТекущийОбъем рюкзака + Объем самой ценной найденной вещи оказались больше, чем допустимоый максимальный Обхем, то придется апихнуть только часть предмета, а затем выходить из цикла и завершать прогу
            int firstValueV = arr[bestItem][0]; //Записываем первоначальный объем предмета
            while (maxV != currentV) //Теперь поштучно кидаем по 1 объему предмета в рюкзак, пока не заполнится полностью
            {
                currentV++;
                arr[bestItem][0]--;
            }
            //Теперь с помощью соотношения первоначального объема к объему оставшемуся после заполнения рюкзака (arr[bestItem][0] / firstValueV) делаем операции
            currentMoney += arr[bestItem][1] * arr[bestItem][0] / firstValueV; //Добавляем только часть стоимости предмета
            arr[bestItem][2] = arr[bestItem][0] / firstValueV; //Записываем в ценность предмета НЕ соотношение объем/цена, а соотношение объем первоначальный / объем оставшийся, чтобы потом вывести его как ответ в процедуре output
            arr[bestItem][1] = 1000000; //Портим цену предмета, это будет визитной карточкой для процедуры output, что этот предмет вместился не полностью, и нужно вывести его соотношение, записанное в предыдущем шаге
            return false; //Возвращаем False, выходим из цикла
        }
}

int bestItem(float **&arr, int &count)
{ //Нахождение самой дешевой еще не закинутой в рюкзак вещи
    float bestItem = 1000000, numberOfItem = 1000000;
    

      
    
    for (int i = 0; i < count; i++) 
        if (bestItem > arr[i][2]) //Очевидно, что раз bestItem == 1000000, то он возьмет первое попавшееся соотношение, а потом со временем получит наибольшее 
        { 
            bestItem = arr[i][2]; //Нашли большее соотношение, записали его соотношение, чтобы в будущем найти большее, если встретится 
            numberOfItem = i; //Записали его номер 
        }
    return 0 ;
}
